% ------------------------------------------------------------------------
%           StormChaser DEMO - Script for using fRapidDH function       --
%                                                                       --
%  (C) Anna Archetti 2014-2016, EPFL
% -----------------------------------------------------------------------
% 
% _______________________________________________________________________
%  [File name]	"StormChaser_DEMO1.m"
%  [Author]		"Anna Archetti"
%  [Version]		"2.0"
%  [Modified by]	"Anna Archetti"
%  [Date]			"30 May 2016"
%
%_________________________________________________________________________
% fRapidDH.m is the main function.
%
% Main software preliminary steps:
% 0a) Parameters definition
% 0b) Find first guess for the seed threshold and the cluster threshold
%     ( the cluster thr: intensity value of the possible max peak 
%       of a lobe
%       the seed thr: value of intensity of the pixel belonging to a lobe )
% 0c) Test the choosen thresholds by checking the file generated by the 
%     software with the images with a red cross overlapped to each found lobe
%     or the images with the pixel corresponding to each lobe color with
%     different colors
%
% Main software steps:
% 1) DH-PSF calibration (dhCalibration.m)
% 2) molecule identification via lobes search (Center of mass approach) 
%    and lobes pairing (CM_forDH)
% 3) first rejection and image segmentation preparetion for step 4)
%   (lobePairRejection.m getParamLocInitGuess.m)
% 4) molecule localization via MLE fitting (MLElocalization.m)
% 5) Result localizations displaying
% 6) Wobble correction
% 7) Result saving
% _______________________________________________________________________
% 
% OUTPUT:
% locList: [ frm, uxA [nm], uyA [nm], uxB [nm], uyB [nm], sgmA [nm], sgmB [nm], I0A, I0B, bkg, corr, xC, yC, zC, ang, dist, varXY, varZ, varAng, exitFITflag]
%          [1	, 2       , 3       , 4       , 5       , 6        , 7        , 8  , 9  , 10 , 11  , 12, 13, 14, 15 , 16  , 17   , 18  , 19    , 20         ]  
%
% ExitFlag:
% = 1 fminsearch converged to a solution x.
% = 0 Maximum number of function evaluations or iterations was reached.
% = -1 Algorithm was terminated by the output function.
% = -2 Algorithm was not converging in the proper way. Since CM-alg more
%      robust assign its estimated parameters
%
% INPUT [for the function CM_forDH.mex - step 2]:
%
% [0] fileData, // Data source file (stack of images).
% [1] fileDark, // Dark frame file (stack of images, optional).
% [2] fileOut, // Bias, noise and gain frame file (stack of 3 images, optional).
% [3] fileBiasScale, // Bias frame scale factor.
% [4] fileNoiseScale, // Noise frame scale factor
% [5] fileGainScale, // Gain frame scale factor
% [6] imgROI.left  // Region of interest
% [7] imgROI.bottom
% [8] imgROI.right
% [9] imgROI.top

% [10] clMode // Clusterizing mode (0 = auto, 1 = absolute, 2 = relative (= to the noise)); 
                                 % (auto without dark = absolute = Pre-calculate thresholds)
% [11] clSeedThr // Seed threshold (absolute value or relative to noise depending on clMode).
% [12] clPixelThr // Pixel threshold (absolute value or relative to noise depending on clMode).
% [13] clRadiusMax // Cluster maximum expected radius (in pixels).
% [14] clLobeDistMin // Minimum distance between two lobes (in pixels).
% [15] clLobeDistMax // Maximum distance between two lobes (in pixels).
% [16] clCutMultMin // Minimum multiplicity to accept a cluster. (before 3)
% [17] clCutDstMin // Minimum distance from a cluster in the previous frame to accept a cluster: 
%                     3*sigma where sigma is the loc precision
%                     = -1  no filter  
% [18] clCutPairDstMin not implemented yet

% [19] glbGain // Global gain scale factor.
% [20] dbgMode // Set debug mode. (2 = cluser found superinposed to the images with different colors; 
%                                  4 = draw a cross; 0 no rendering
%                                  1 = print stack with statistic mean-frame, std-SEM-frame, gain-frame(not yet implemented) )
% Pixel that are part of two overlapping lobes have a color in between the
% two clusters
% [21] dbgFrame // Output a specific debug frame file (all if not specified). [0 = all frames]
% [22] frmCount // Limits the number of frames to be parsed (optional). [0 = all frames]
% [23] numFrmFilt // Limit the number of frames for computing the low pass filter
                       % If (frmCountFilter == 0 || frmCountFilter > data.frmCount()) frmCountFilter = data.frmCount();

% OUTPUT [for the function CM_forDH.m - step 2] :
%
% idList = [frm, Xc, Yc, dst, ang, Xa, Ya, Xb, Yb, Ia, Ib, heightA, widthA, heightB, widthB] Ia, Ib = pixel values sum
% idList = [1  , 2 , 3 , 4  , 5  , 6 , 7 ,  8,  9, 10, 11, 12     , 13    , 14     , 15    ] 
% !!!!!!!!!!!!! all in pix, frame start from 0 at this step !!!!!!!!!!!
% !!!!!!!!!!!!!       ang = arctan(deltaY, deltaX)          !!!!!!!!!!!
%___________________________________________________________________________________________________________
% INPUT [for MLElocalization(image, pixSize, params0, varianceCheck, plotCheck, offset) - step 3]; 
%
% - image: image croped around the Guess PSF to fit
% - pixSize
% - params0: [uxA [nm], uyA [nm], uxB [nm], uyB [nm], sgmA [nm], sgmB [nm], I0A, I0B, bkg]
% - varianceCheck: 
% - plotCheck: 1 plot, 0 not plot
% - offset: a constant offset added by the camera before the pixel is
%           read out. 
%___________________________________________________________________________________________________________
% OUTPUT [step 3]
%
% - locList: [ frm, uxA [nm], uyA [nm], uxB [nm], uyB [nm], sgmA [nm], sgmB [nm], I0A, I0B, bkg, corr, xC, yC, zC, ang, dist, varXY, varZ, varAng, exitFITflag]
%            [1	  , 2       , 3       , 4       , 5       , 6        , 7        , 8  , 9  , 10 , 11  , 12, 13, 14, 15 , 16  , 17   , 18  , 19    , 20         ]  
%
% ExitFITflag:
% = 1 fminsearch converged to a solution x.
% = 0 Maximum number of function evaluations or iterations was reached.
% = -1 Algorithm was terminated by the output function.
%
%___________________________________________________________________________________________________________


%%
clc
clear all


%% Step 0a) Define parameters
% Do ctrl + enter after positiong the cursor here

% Find the warning ID, save the current warning state
% [msgStr,msgId] = lastwarn;
% Disable the specific warning

warning('off','MATLAB:MKDIR:DirectoryExists');
warning('off', 'MATLAB:imagesci:tiffmexutils:libtiffWarning');

currFolder = pwd;
addpath(currFolder);
addpath([currFolder '\StormChaser'])
addpath([currFolder '\StormChaser\Cal_forDH'])
addpath([currFolder '\StormChaser\Loc_forDH'])
addpath([currFolder '\StormChaser\Loc_forDH\QuadTree\QuadTree'])
addpath([currFolder '\StormChaser\general_dependences'])

% Camera parameters
%--------------------------------------------------------------------------
QE = 0.9; % Photon converter factor or Quantum efficiency (QE) e-/Ph.
pixSize = 100; % Pixel size [nm]

% Camera noise characterization
fileBiasScale = 1;
fileNoiseScale = 1;
fileGainScale = 1;

% Optics
%--------------------------------------------------------------------------
WL = 660; % Wavelength [nm]
NA = 1.49; % Numerical aperture (NA)= n*D/2f = lambda/pi*w; 2w=beam diam 	
NIcover = 1.5; % reflactive index of the glass
NIsample = 1.3; % reflactive index of the baffer

maxDepthRange = 750; % max depth [nm]
minDepthRange = -750; % min depth [nm]

% Read-out: Gaussian distribution	74.4	
EM = 300.0; % EMGain: Gamma	
% Spurious noise: Poisson distribution	0.0020	

% Analog Digital Conversion
%--------------------------------------------------------------------------
eADU = 45.00; % Electron conversion e- per ADU	
TOTgain = QE*EM/eADU; % Total gain: QE*EM_gain/e_per_ADU	6.00

% Localization step: Data directory, files, inputs 
%--------------------------------------------------------------------------
% Input for identification and localization step: Files names
fileData = [currFolder '\Dataset\substack-4000-MT0.N1.LD-DH-Exp90right.tif'];
fileDark = '';

% Output Folders
fileOutDir = [currFolder '\ResultAnalysis']; % Molecules Localization folder
mkdir(fileOutDir);
fileOutLocCMDir = [currFolder '\ResultCMalg\DatasetLocTest']; % Molecules Identification folder (molecules identificaiton with the center of mass algorithm)
fileOutLocCMDirFileName = [fileOutLocCMDir '\DatasetLocTest'];
mkdir(fileOutLocCMDir);

% Grab file info.
imgInfo = imfinfo(fileData);
numFrm = numel(imgInfo); % If (numFrm == 0 || numFrm > data.frmCount()) numFrm = data.frmCount();

% Give image width and height
colNum = imgInfo(1).Width;
rowNum = imgInfo(1).Height;

% Fitting type
fitMLE = 0; % fitMLE = 0 means that the fit will be a LS fit 
            % fitMLE = 1 means that the fit will be a MLE fit
            
             % Multi-emitters fitting
multiEm = 1; % 1 yes, 0 no

% ROI
%--------------------------------------------------------------------------
ROIleft = 0;
ROIbottom = 0;
ROIright = rowNum;
ROItop = colNum;

% Center of mass thresholds
%--------------------------------------------------------------------------
% Lobe thresholds
clMode = 1; % Clusterizing mode (0 = auto, 1 = absolute, 2 = relative (= to the noise)); 
                              % (auto without dark = absolute = Pre-calculate thresholds)
                              % If clMode = 2 --> clSeedThr should be of the order of 3, 4
                              % = 3, 4 sigma over the baseline 
                              % If clMode = 1 --> clSeedThr should be over the bkg
                              % level of the image
                        
% clSeedThr = 340; % 70 MT0 % 300 MT0N1LD 300
% clPixelThr = 320; % 60 MT0 % 280 MT0N1LD 280
clSeedThr = 1500; % 70 MT0 % 300 MT0N1LD 300 5 4.8 800 4.5 170
clPixelThr = 1300; % 60 MT0 % 280 MT0N1LD 280 4.5 4.4 790 4.4 160
numFrmFilt = 0; % How many frame to compute the filter (0 = no filter; if > numFrmCal = subtract mean)
                  % If (numFrmCal > data.frmCount()) numFrmCal =
                  % data.frmCount(); 50
                  
repNum = 1; %8

clRadiusMax = 7; % 8 % 9 % 5 %6 %7
clLobeDistMin = 7; % this is only an initial guess it will be redefined after calibration %9
clLobeDistMax = 14; %14

clCutMultMin = 4; %4 % 9 % 16
clCutDstMin = 2; % 2
clCutPairDstMin = 0; % not yet implemented

% Debug parameters
%--------------------------------------------------------------------------
glbGain = 1;
dbgMode = 0; % 4 = print a stack of images with the lobes localization with red cross overlapped
             % 0 = no debag stack
             % 2 = print stack with colored pixel corresponding to each lobe
             % 1 = print stack with statistic noise frame gain frame offset
             %     frame (1^ framse mean, 2^ frame std SEM, 3^ frame gain)
dbgFrame = 0; % 0 all frame, num = frame number
dbgModeAfterRej = 0; % 1 = print a stack of images with the lobes localization with red cross overlapped
             % 0 = no debag stack
dbgFrameAfterRej = 300; % 0 all frame, num = frame number
frmCountDBG = 50; % how many frame to analyse in the identification step debug
frmCount = 0; % how many frame to analyse in the identification step (0 = all)

varianceCheck = 1; % 0 do not compute the variance, 1 yes
plotCheckLS = 0; % 0 do not show fig, 1 yes
plotCheckMLE = 0; % 0 do not show fig, 1 yes
figDbgCrop = 0; % 0 do not show fig, 1 yes (remember to comment out "parfor" in the function fRapidDH)


% Calibration step: Data directory, files, inputs 
%--------------------------------------------------------------------------
% Input for the calibration step: Files names
calFileImg = [currFolder '\Dataset\beadPSF90right.tif'];
calFileDark = '';
calFileDat =  [currFolder '\Dataset\calibBeadPSF.csv'];

% Output files
fileOutCalDir = [currFolder '\Calibration\CalibLocTest'];
mkdir(fileOutCalDir);
fileOutCalDirFileName = [fileOutCalDir '\CalibLocTest'];

% Camera noise characterization
fileBiasScaleCal = 1;
fileNoiseScaleCal = 1;
fileGainScaleCal = 1;

% Grab file info.
imgInfoCal = imfinfo(calFileImg);
numFrmCal = numel(imgInfoCal); 

% Give image width and heigh
colNumCal = imgInfoCal(1).Width;
rowNumCal = imgInfoCal(1).Height;

% ROI
ROIleftCal = 0;
ROIbottomCal = 0;
ROItopCal = rowNumCal;
ROIrightCal = colNumCal;

% Lobe thresholds
clModeCal = 1; % 1
clSeedThrCal = 4000; % 130 % 900 % 2200 900 3450 10^10.4 10^7.2 4400
clPixelThrCal = 3000; % 100 % 800 % 1400 820 3400 10^10 10^6.8 2400

numFrmFiltCal = 0; % Better no filtering (0)
                   % How many frame to compute the filter (0 = no filter; if > numFrmCal = subtract mean)
                   % If (numFrmCal > data.frmCount()) numFrmCal = data.frmCount();
repNumCal = 1;
                   
clRadiusMaxCal = 6; %6 5
clLobeDistMinCal = 7; %9
clLobeDistMaxCal = 15; %14

clCutMultMinCal = 9; %
clCutDstMinCal = -1; % -1 = no filter
clCutPairDstMinCal = 0;

% Debug
glbGainCal = 1;
dbgModeCal = 0;
dbgFrameCal = 0;
plotCheckMLECal = 0;
plotCheckLSCal = 0;
figDbgCropCal = 0; % 0 do not show fig


%% Step 0b): Preliminary test: Grab the possible thresholds for the calibration beads: first thresholds guess 
% Do ctrl + enter after positiong the cursor here

[clSeedThr, clPixelThr] = getThrGuess(fileData, 2500, 0, numFrmFilt);

[clSeedThrCal, clPixelThrCal] = getThrGuess(calFileImg, numFrmCal, 1, numFrmFiltCal);

disp('Guessed clThr and seedThr:')
disp([clSeedThr, clPixelThr])

disp('Guessed clThrCal and seedThrCal:')
disp([clSeedThrCal, clPixelThrCal])

%% Step 0c): Preliminary test: choose the right thresholds for the calibration beads
% Do ctrl + enter after positiong the cursor here

[testCalList] = CM_forDH( calFileImg, calFileDark, fileOutCalDirFileName,...
                              fileBiasScaleCal, fileNoiseScaleCal, fileGainScaleCal, ...
                              ROIleftCal, ROIbottomCal, ROIrightCal, ROItopCal, ...
                              clModeCal, clSeedThrCal, clPixelThrCal, clRadiusMaxCal, clLobeDistMinCal, clLobeDistMaxCal, ...
                              clCutMultMinCal, clCutDstMinCal, clCutPairDstMinCal, ...
                              glbGainCal, 2, 0, 0, numFrmFiltCal, repNumCal); 
                          % Please check the output :
                         % CalibLocTest_DBG_Stack_RGBA.tif
                          
% Check if there is at least for each frame one lobe pair                          
[checkOneLobePerFrm] = checkLobNum(testCalList, numFrmCal);
% If there is not a lobe in each frame
if ~isempty(find(checkOneLobePerFrm == 0)) 
    noLobFrmIdx = find(checkOneLobePerFrm == 0);
    warning('Change calibration thresholds.')
    error('Calibration: lobe not found. Frame: %d . \n Change calibration thresholds.', noLobFrmIdx)  
end

if ~isempty(find(checkOneLobePerFrm == 1000))
    moreThanOneLobFrmIdx = find(checkOneLobePerFrm == 1000);
    error('Change calibration thresholds. More than one lobe found per frame. Frame: %d . \n Change calibration thresholds.', moreThanOneLobFrmIdx')
end

CM_forDH( calFileImg, calFileDark, fileOutCalDirFileName,...
                              fileBiasScaleCal, fileNoiseScaleCal, fileGainScaleCal, ...
                              ROIleftCal, ROIbottomCal, ROIrightCal, ROItopCal, ...
                              clModeCal, clSeedThrCal, clPixelThrCal, clRadiusMaxCal, clLobeDistMinCal, clLobeDistMaxCal, ...
                              clCutMultMinCal, clCutDstMinCal, clCutPairDstMinCal, ...
                              glbGainCal, 4, 0, 0, numFrmFiltCal, repNumCal); 
                          % Please check the output :
                          % CalibLocTest_DBG_Stack_HiRes_RGBA.tif
                          
%% Step 0d): Test to choose the right thresholds for the dataset                          
%  Do ctrl + enter after positiong the cursor here                    
[testDataList] = CM_forDH( fileData, fileDark, fileOutLocCMDirFileName,...
                              fileBiasScale, fileNoiseScale, fileGainScale, ...
                              ROIleft, ROIbottom, ROIright, ROItop, ...
                              clMode, clSeedThr, clPixelThr, clRadiusMax, clLobeDistMin, clLobeDistMax, ...
                              clCutMultMin, clCutDstMin, clCutPairDstMin, ...
                              glbGain, 2, 0, frmCountDBG, numFrmFilt, repNum); 
                          % Please check the output :
                          % DatasetLocTest_DBG_Stack_RGBA.tif
                         
CM_forDH( fileData, fileDark, fileOutLocCMDirFileName,...
                              fileBiasScale, fileNoiseScale, fileGainScale, ...
                              ROIleft, ROIbottom, ROIright, ROItop, ...
                              clMode, clSeedThr, clPixelThr, clRadiusMax, clLobeDistMin, clLobeDistMax, ...
                              clCutMultMin, clCutDstMin, clCutPairDstMin, ...
                              glbGain, 4, 0, frmCountDBG, numFrmFilt, repNum); 
                          % Please check the output :
                          % DatasetLocTest_DBG_Stack_HiRes_RGBA.tif


%% Analyse the dataset to extract the localization
% Step 1), 2), 3) and 4)
% Do ctrl + enter after positiong the cursor here

[locList, locLSListCal, xInterpFunc, yInterpFunc, distInterpFunc] = fRapidDH( fileData, fileDark, fileOutDir, fileOutLocCMDir,...
                          fileBiasScale, fileNoiseScale, fileGainScale, ...
                          fitMLE, multiEm,...
                          ROIleft, ROIbottom, ROIright, ROItop, ...
                          clMode, clSeedThr, clPixelThr, clRadiusMax, clLobeDistMin, clLobeDistMax, ...
                          clCutMultMin, clCutDstMin, clCutPairDstMin, ...
                          glbGain, dbgMode, dbgFrame, dbgModeAfterRej, dbgFrameAfterRej, pixSize, varianceCheck, plotCheckMLE, plotCheckLS, ...
                          figDbgCrop, frmCount, numFrmFilt, repNum, ...
                          calFileImg, calFileDark, calFileDat, fileOutCalDir,...
                              fileBiasScaleCal, fileNoiseScaleCal, fileGainScaleCal, ...
                              ROIleftCal, ROIbottomCal, ROIrightCal, ROItopCal, ...
                              clModeCal, clSeedThrCal, clPixelThrCal, clRadiusMaxCal, clLobeDistMinCal, clLobeDistMaxCal, ...
                              clCutMultMinCal, clCutDstMinCal, clCutPairDstMinCal, ...
                              glbGainCal, dbgModeCal, dbgFrameCal, plotCheckMLECal, ...
                              plotCheckLSCal, figDbgCropCal, numFrmFiltCal, repNumCal);
                        
% Display info
disp('Final Localization List: locList.m')
disp('[ frm, uxA [nm], uyA [nm], uxB [nm], uyB [nm], sgmA [nm], sgmB [nm], I0A, I0B, bkg, corr, xC, yC, zCInt, zCFit, ang, dist, varXY, varZ, varAng, exitFITflag]')
disp('[ 1  , 2       , 3       , 4       , 5       , 6        , 7        , 8  , 9  , 10 , 11  , 12, 13, 14   , 15   , 16 , 17  , 18   , 19  , 20    , 21         ]')
disp(' ') 
disp('Final Calibration Localization List: locLSListCal.m')
disp('[frm, uxA [nm], uyA [nm], uxB [nm], uyB [nm], sgmA [nm], sgmB [nm], I0A, I0B, bkg, corr,  xC, yC, zC, ang, dist, varXY, varAng, exitFITflag]')
disp('[1  , 2       , 3       , 4       , 5       , 6        , 7        , 8  , 9  , 10 , 11  , 12 , 13, 14, 15 , 16  , 17   , 18    , 19         ]')         

%% Final filtering

% Grab the sigma range of the two lobes inside the calibration list
sgmMin = min([min(locLSListCal(:, 6)), min(locLSListCal(:, 7))]);
sgmMax = max([max(locLSListCal(:, 6)), max(locLSListCal(:, 7))]);
distMin =  min(locLSListCal(:, 17));
distMax =  max(locLSListCal(:, 17));
minDepthRange = min(locLSListCal(:, 14));
maxDepthRange = max(locLSListCal(:, 14));

molNum = size(locList, 1);
% Add column with mol idx !! columm = 22
locListTemp = locList;
locList(:, end + 1) = (1 : 1 : molNum);
maxDist = 200; % [in nm]
numClosMol = 3; % closest mol num

% Group molecules that are closest in the same 3 consecutive frm by 
% assigning the same group index !! column = 23
[locList] = grabGroupMolListConsFrm(locList, maxDist, numClosMol);

% If they belong to the same group assign to all of them the localization
% info of the best localized one
for grIdx = 1: max(locList(:, 23))
    
    tempList = locList(locList(:, 23) == grIdx, :);
%     [val, idxMin] = min(locList(locList(:, 23) == grIdx, 18));
    [val, idxMin] =  min( (tempList(:, 6) - sgmMin).^2 + (tempList(:, 7) - sgmMin).^2 + ...
         (tempList(:, 6) - sgmMax).^2 + (tempList(:, 7) - sgmMax).^2 );
    bestMolIdx = tempList(idxMin, 22);
    locList(locList(:, 23) == grIdx, 2:21) = repmat(locList(bestMolIdx, 2:21), [size(tempList,1) 1 1]);
end
%%
idxZRange = locList(:, 14) > minDepthRange & locList(:, 14) < maxDepthRange;
idxXRange = locList(:, 12) >= 0 & locList(:, 12) <= colNum*pixSize;
idxYRange = locList(:, 13) >= 0 & locList(:, 13) <= rowNum*pixSize;
idxSgmRange = locList(:, 6) >= sgmMin - 300 & locList(:, 7) >= sgmMin - 300 ... % 25 50 % MT3 200
            & locList(:, 6) <= sgmMax + 250 & locList(:, 7) <= sgmMax + 250;    % 20 % MT3 200
idxDistVal = distInterpFunc(locList(:, 14));
idxDistRange = locList(:, 17) >= idxDistVal - 300  & locList(:, 17) <= idxDistVal + 300; % 70 150 % MT3 300
%idxDistRange = locList(:, 17) >= distMin - 20  & locList(:, 17) <= distMax + 20;
idxGoodFit = locList(:, 21) == 3 & locList(:, 18) < 70000 & locList(:, 18) > 10; % MT3 20000 % MT1-2 1000/500== 3 means fitting converging + 
% fitting with a computed rough xy variance extimation smaller than 70nm 

locListFinal = locList( idxZRange & ... % right z range
    idxXRange & ... % right x range
    idxYRange & ... % right y range
    idxSgmRange &... % right sigma range
    idxDistRange &... % right interlobe distance range
    idxGoodFit  ... % right fitting  
     , :);

%locListFinal = locList;
 
disp('  ');
disp('Post-processing:')
disp('1) Final localization list after rejection saved in: locListFinal.m'); 

%% Correction for spherical aberration (aqueous sample + oil immersion objective)
% The index mismatch causes the apparent z position of the molecule to
% shift away from the coverglass due to the bending of light rays that
% occurs at the interface of two different material
% This distortion in z: corrected via a rescaling Zactual = k*Zmeasured
k = RIsample/RIcover; 
locListFinal(:, 14) = locListFinal(:, 14)*k;

%% Intensity Conversion from ADU to photons
IA = locListFinal(:, 8);
IB = locListFinal(:, 9);
smgA = locListFinal(:, 6)/pixSize;
smgB = locListFinal(:, 7)/pixSize;
locListFinal(:, 24) = (IA.*2.*pi.*smgA.^2 + IB.*2.*pi.*smgB.^2)./TOTgain;

disp('2) Conversion from ADU to photons');
disp('3) Molecule Intensity in col 24');

 %% Wobble correction
deltaX = xInterpFunc(locListFinal(:, 14)) - xInterpFunc(0);
deltaY = yInterpFunc(locListFinal(:, 14)) - yInterpFunc(0);

locListFinal(:, 12) = locListFinal(:, 12) - deltaX;
locListFinal(:, 13) = locListFinal(:, 13) - deltaY;

disp('4) Wobble correction done.');

%% Rendering: plot 2D and 3D hist
% Step 5)

% 1.	Install dipimage toolbox (http://www.diplib.org/)
% 2.	Initialize it.
% Enter in matlab:

run('C:\Program Files\DIPimage 2.7\dipstart.m');


figure, plot(locListFinal(:, 12), locListFinal(:, 13),'k.', 'MarkerSize', 0.01)
xlabel('x [\mum]');ylabel('y [\mum]');
title([num2str(size(locListFinal, 1)) ' Localizations'],'color','k');

figure,
scatter3( locListFinal(:, 12), locListFinal(:, 13), locListFinal(:, 14), 2, locListFinal(:, 14));
colormap(jet);
xlabel('x [\mum]');ylabel('y [\mum]');zlabel('z [\mum]');
title([num2str(size(locListFinal, 1)) ' Localizations'],'color','k');
set(gca,'color','w');
set(gca,'xcolor','k');set(gca,'ycolor','k');set(gca,'zcolor','k');

figure,
scatter( locListFinal(:, 12), locListFinal(:, 13), 2, locListFinal(:, 14));
colormap(jet);
xlabel('x [\mum]');ylabel('y [\mum]');
title([num2str(size(locListFinal, 1)) ' Localizations'],'color','k');
set(gca,'color','w');
set(gca,'xcolor','k');set(gca,'ycolor','k');set(gca,'zcolor','k');
  

% Here we print the reconstructed image (swicth on molecule centers)
% Reconstruction: 2D histogram image
M = 20;
sz = [rowNum, colNum];
imageRec = cHistRecon(sz(1)*M, sz(1)*M, single(locListFinal(:, 12).*M./pixSize), single(locListFinal(:, 13).*M./pixSize), 0);
% cHistRecon generates 2D histogram images using the input size and
% localization information. Courtesy of Keith A. Lidke, UNM.

% Display using dipimage
hist1 = figure;
dipshow(hist1, imageRec, [0 1])
diptruesize(50)
set(hist1, 'name', '2D histogram image (50%)', 'numbertitle', 'off')

hist2 = figure;
dipshow(hist2, gaussf(imageRec, [3 3]), [0 0.5])
diptruesize(50)
set(hist2, 'name', 'Gaussian blurred image (50%)', 'numbertitle', 'off')


%% Save loc in a csv, tab sep, ascii file
% Step 6)
disp('...writing data...')

% fileOutDir
% fileOutDirData = ['C:\Users\aarchett\Documents\MATLAB\DH_segm_prog_test\DatasetForSoftwareComparison\MT0N1LD\ResultAnalysisRapid\' datestr(now,'yyyymmdd') 'resultLSFinalFilt'];
% mkdir(fileOutDir);
dataWrite(locListFinal, fileOutDir);
disp('...data saved.')







